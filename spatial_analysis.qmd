# Spatial Analysis

```{r setup, include=FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
```

 
```{r}
# Load libraries
library(tidyverse)
library(sf)
library(terra)
library(units)
library(tmap)
```

## Load the datasets
```{r}
# Load vector datasets
water <- read_sf("Datafiles/spatial_data/water.shp")
svalbard <- read_sf("Datafiles/spatial_data/svalbard.shp")
watershed <- read_sf("Datafiles/spatial_data/watershed5.shp")
stations <- read_sf("Datafiles/spatial_data/sampling_stations.shp")

#Load raster datasets
dem <- rast("Datafiles/spatial_data/dem.tif")
ndvi <- rast("Datafiles/spatial_data/NDVI.tif")
veg_map <- rast("Datafiles/spatial_data/vegetation.tif")
```

## Plotting the vector data and preparing it for analysis
### Plotting the data

```{r}
# Plot the watershed with baseR functions
plot(st_geometry(watershed))
```

 
```{r}
# We can use Tmap for more elaborate maps
# We can switch between plot mode and view mode
# tmap_mode(mode = c("plot", "view"))

tmap_mode(mode = c("plot"))

tm_shape(watershed) +
tm_polygons() +
tm_shape(svalbard) +
tm_polygons(col = "beige") +
tm_graticules() +
tm_shape(watershed) +
tm_polygons(col = "name", title='Watershed') +
tm_shape(water) +
tm_fill(col = "blue") +
tm_shape(stations) +
tm_dots(size = 0.25) +
tm_scale_bar(breaks = c(0, 10, 20)) +
tm_compass(position = c("left", "top")) +
tm_layout(bg.color = "lightblue")
```

 
### Preparing the vector data to match coodinate systems and extents

```{r}
# Assessing coordinate systems
crs(watershed, describe= "TRUE")
crs(stations, describe= "TRUE")

# Project the spatial file
stations_projected = st_transform(stations, "EPSG:32633")

# Subset for one of the watersheds
watershed = subset(watershed, name == "Adventelva")
station = subset(stations_projected, Station == "Adventelva")
```

### Calculate the slope

```{r}
# Crop the DEM to the extent of the watersheds to speed up processing
dem <- crop(dem, vect(watershed))
dem <- mask(dem, vect(watershed))

plot(dem)

# Calculate slope from the DEM
slope <- terrain(dem, v = "slope", neighbors = 8, unit = "degrees")

plot(slope)
```

### NDVI

```{r}
# Crop the NDVI to the extent of the watersheds to speed up processing
ndvi <- crop(ndvi, vect(watershed))
ndvi <- mask(ndvi, vect(watershed))

# NDVI
ndvi

# Change the range to be between -1 and 1
ndvi <- ndvi/1000

plot(ndvi)
```

### Vegetation map

```{r}
# We can plot the map to look at it
plot(veg_map)

# Crop the veg map to the extent of the watersheds to speed up processing
veg_map <- crop(veg_map, vect(watershed))
veg_map <- mask(veg_map, vect(watershed))

# Reclassify the vegetation map to a smaller number of categories
# Reclassification matrix
rclmat<-read.table("datafiles/spatial_data/rclmat.txt",header=TRUE,row.names=1)

# Reclassify the map to simples classes with help of the matrix
veg_rcl <- classify(veg_map, rclmat, include.lowest=TRUE)

# Now we can look at the results
plot(veg_rcl)
```

## Generating new data layers from existing data
### Calculate the distance to each sampling station
```{r}
# Create a raster (30m resolution) based on the shape of the watershed
r <- rast(watershed, res=30)
r_wat <- rasterize(watershed, r)

# Calculate the distance for each pixel to the sampling station
r_dis <- distance(r_wat, station)

# Crop to the extent of the watershed shapefile
r_dis <- crop(r_dis, vect(watershed))
r_dis <- mask(r_dis, vect(watershed))

# Give it a nicer name
distance <- r_dis

# Look at the result
plot(distance)
plot(st_geometry(watershed), add=TRUE)
```


## Overlaying the data to export
### Preparing the overlay

```{r}
# Project the raster files to vegetation classes map, this is necessary for overlays
ndvi_prj <- project(ndvi, veg_rcl)
slope_prj <- project(slope, veg_rcl)
distance_prj <- project(distance, veg_rcl)
```

### Exploring the raster data

```{r}
# Explore the raster layers
tmap_mode(mode = c("view"))
cls<-c("blue", "lightblue", "white")

tmap_options(check.and.fix = TRUE)

tm_shape(watershed) +
  tm_borders() +
tm_shape(station) +
  tm_dots()+
tm_shape(slope_prj) +
  tm_raster(alpha = 0.4, title='Slope - degrees') +
  tm_shape(distance_prj) +
  tm_raster(style = "fixed", breaks = c(0,2000,10000,40000), palette=cls,  title='Distance to Station')
```

### Overlay files and extract as dataframe

```{r}
# We stack all the layers on top of each other
stack <- c(veg_rcl, ndvi_prj, slope_prj, distance_prj)

# We extract all the stacked data for each watershed, this produces a long table with a row for each column
watershed_df <- terra::extract(stack, vect(watershed))
```

### Cleaning the dataframe

```{r}
# We select the columsn we are interested in and rename them
watershed_df <- dplyr::select(watershed_df, vegetation,
                              ndvi = NDVI,
                              slope, distance = layer)
# Rename vegetation classes
watershed_df <- mutate(watershed_df,
                     vegetation = case_when(
                       vegetation == 2 ~ 'water',
                       vegetation == 3 ~ 'shadow',
                       vegetation == 4 ~ 'glacier',
                       vegetation == 5 ~ 'barren',
                       vegetation == 6 ~ 'heath',
                       vegetation == 7 ~ 'moss'))

# Change vegetation classes to factors
watershed_df$vegetation<-as.factor(watershed_df$vegetation)

# We can save the file
# write_csv(watershed_df, file = "datafiles/spatial_data/watershed_dataframe.csv")
```

## Calculate  area of watershed
```{r}
# Define the spatial unit
watershed$watershed_area <- set_units(st_area(watershed), "km2")

# Drop the geometry to obtain a dataframe
watershed_info = st_drop_geometry(watershed)

# Change the area to numeric format
watershed_info$watershed_area <- as.numeric(watershed_info$watershed_area)

# Select and rename columns that are interesting to keep
watershed_info <- dplyr::select(watershed_info, watershed = name, watershed_km2 = watershed_area)

# Save the file if you want to:
# write_csv(watershed_info, file = "Datafiles/spatial_data/watershed_info.csv")
```
